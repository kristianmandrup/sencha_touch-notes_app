// Generated by CoffeeScript 1.3.3
/*
Copyright (c) 2012 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/*
Jasmine test suite for Deft.promise.Promise
*/

describe('Deft.promise.Promise', function() {
  beforeEach(function() {
    this.addMatchers({
      toBeInstanceOf: function(className) {
        return this.actual instanceof Ext.ClassManager.get(className);
      }
    });
  });
  describe('when()', function() {
    var cancelCallback, deferred, failureCallback, progressCallback, successCallback;
    deferred = null;
    successCallback = failureCallback = progressCallback = cancelCallback = null;
    beforeEach(function() {
      deferred = Ext.create('Deft.promise.Deferred');
      successCallback = jasmine.createSpy('success callback');
      failureCallback = jasmine.createSpy('failure callback');
      progressCallback = jasmine.createSpy('progress callback');
      cancelCallback = jasmine.createSpy('cancel callback');
    });
    it('should return an immediately resolved Promise when a value specified', function() {
      var promise;
      promise = Deft.promise.Promise.when('expected result').then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('resolved');
      expect(successCallback).toHaveBeenCalledWith('expected result');
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      return expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new resolved Promise when a resolved Promise is specified', function() {
      var promise;
      deferred.resolve('expected result');
      promise = Deft.promise.Promise.when(deferred.getPromise()).then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('resolved');
      expect(promise).not.toBe(deferred.getPromise());
      expect(successCallback).toHaveBeenCalledWith('expected result');
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      return expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new rejected Promise when a rejected Promise is specified', function() {
      var promise;
      deferred.reject('error message');
      promise = Deft.promise.Promise.when(deferred.getPromise()).then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('rejected');
      expect(promise).not.toBe(deferred.getPromise());
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).toHaveBeenCalledWith('error message');
      expect(progressCallback).not.toHaveBeenCalled();
      return expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new pending (and immediately updated) Promise when a pending (and updated) Promise is specified', function() {
      var promise;
      deferred.update('progress');
      promise = Deft.promise.Promise.when(deferred.getPromise()).then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('pending');
      expect(promise).not.toBe(deferred.getPromise());
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).toHaveBeenCalledWith('progress');
      return expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new cancelled Promise when a cancelled Promise specified', function() {
      var promise;
      deferred.cancel('reason');
      promise = Deft.promise.Promise.when(deferred.getPromise()).then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('cancelled');
      expect(promise).not.toBe(deferred.getPromise());
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      return expect(cancelCallback).toHaveBeenCalledWith('reason');
    });
    it('should return a new pending Promise that resolves when the pending Promise specified is resolved', function() {
      var promise;
      promise = Deft.promise.Promise.when(deferred.getPromise()).then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('pending');
      expect(promise).not.toBe(deferred.getPromise());
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
      deferred.resolve('expected result');
      expect(promise.getState()).toBe('resolved');
      expect(successCallback).toHaveBeenCalledWith('expected result');
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      return expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new pending Promise that rejects when the pending Promise specified is rejected', function() {
      var promise;
      promise = Deft.promise.Promise.when(deferred.getPromise()).then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('pending');
      expect(promise).not.toBe(deferred.getPromise());
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
      deferred.reject('error message');
      expect(promise.getState()).toBe('rejected');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).toHaveBeenCalledWith('error message');
      expect(progressCallback).not.toHaveBeenCalled();
      return expect(cancelCallback).not.toHaveBeenCalled();
    });
    it('should return a new pending Promise that updates when the pending Promise specified is updated', function() {
      var promise;
      promise = Deft.promise.Promise.when(deferred.getPromise()).then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('pending');
      expect(promise).not.toBe(deferred.getPromise());
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
      deferred.update('progress');
      expect(promise.getState()).toBe('pending');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).toHaveBeenCalledWith('progress');
      return expect(cancelCallback).not.toHaveBeenCalled();
    });
    return it('should return a new pending Promise that cancels when the pending Promise specified is cancelled', function() {
      var promise;
      promise = Deft.promise.Promise.when(deferred.getPromise()).then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback
      });
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('pending');
      expect(promise).not.toBe(deferred.getPromise());
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      expect(cancelCallback).not.toHaveBeenCalled();
      deferred.cancel('reason');
      expect(promise.getState()).toBe('cancelled');
      expect(successCallback).not.toHaveBeenCalled();
      expect(failureCallback).not.toHaveBeenCalled();
      expect(progressCallback).not.toHaveBeenCalled();
      return expect(cancelCallback).toHaveBeenCalledWith('reason');
    });
  });
  describe('all()', function() {});
  describe('any()', function() {});
  describe('memoize()', function() {});
  describe('map()', function() {});
  describe('reduce()', function() {});
  describe('then()', function() {});
  describe('always()', function() {});
  return describe('cancel()', function() {});
});
